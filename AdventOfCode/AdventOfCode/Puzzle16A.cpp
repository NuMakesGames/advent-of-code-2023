#include "pch.h"

#include "../Utilities/Utilities.h"
#include "PuzzleSolvers.h"

using namespace Utilities;
using namespace std::literals::chrono_literals;

namespace Puzzle16A
{
	constexpr Vector2d<int> up = { 0, -1 };
	constexpr Vector2d<int> down = { 0, 1 };
	constexpr Vector2d<int> left = { -1, 0 };
	constexpr Vector2d<int> right = { 1, 0 };

	struct Ray
	{
		Vector2d<int> direction;
		Vector2d<int> start;

		auto operator<=>(const Ray&) const = default;
	};
} // namespace Puzzle16A

IMPLEMENT_STD_HASH(Puzzle16A::Ray, value.direction, value.start);

namespace Puzzle16A
{
	// Compute where a given ray ends
	Vector2d<int> FindRayEnd(const Grid2d<char>& grid, const Ray& ray)
	{
		Vector2d<int> pos = ray.start;

		bool isEnd = false;
		while (!isEnd)
		{
			pos += ray.direction;
			if (!grid.IsInBounds(pos))
			{
				pos -= ray.direction;
				break;
			}

			char c = grid.at(pos);
			isEnd = (c == '\\' || c == '/') || ((ray.direction == up || ray.direction == down) && c == '-')
			     || ((ray.direction == left || ray.direction == right) && c == '|');
		}

		return pos;
	}

	void PrintSolution(const std::filesystem::path& inputFile, bool shouldRender)
	{
		Grid2d<char> grid = ReadAllLinesInFileAsGrid(inputFile);

		// Store all rays generated by the grid
		std::unordered_map<Ray, Vector2d<int>> rays;

		// Create rays from every mirror and splitter
		for (int y = 0; y < grid.Height(); ++y)
		{
			for (int x = 0; x < grid.Width(); ++x)
			{
				char c = grid.at(x, y);
				if (c == '.')
				{
					continue;
				}

				Ray upRay{ up, { x, y } };
				Ray downRay{ down, { x, y } };
				Ray leftRay{ left, { x, y } };
				Ray rightRay{ right, { x, y } };

				switch (c)
				{
					case '.':
						break;
					case '/':
					case '\\':
						rays.insert({ upRay, FindRayEnd(grid, upRay) });
						rays.insert({ downRay, FindRayEnd(grid, downRay) });
						rays.insert({ leftRay, FindRayEnd(grid, leftRay) });
						rays.insert({ rightRay, FindRayEnd(grid, rightRay) });
						break;
					case '|':
						rays.insert({ upRay, FindRayEnd(grid, upRay) });
						rays.insert({ downRay, FindRayEnd(grid, downRay) });
						break;
					case '-':
						rays.insert({ leftRay, FindRayEnd(grid, leftRay) });
						rays.insert({ rightRay, FindRayEnd(grid, rightRay) });
						break;
				}
			}
		}

		// Start with the source ray
		Ray sourceRay{ right, { -1, 0 } };
		rays.insert({ sourceRay, FindRayEnd(grid, sourceRay) });

		// Track energized tiles
		Grid2d<char> energizedTiles{ grid.Width(), grid.Height() };
		std::ranges::fill(energizedTiles, '.');

		ConsoleRenderer renderer{ energizedTiles.Width(), energizedTiles.Height(), 1 };
		if (shouldRender)
		{
			renderer.SetTimeToWaitAfterPresent(1ms);
			renderer.SetRestoreCursorAfterPresent(false);
			renderer.DrawGrid(0, 0, grid, ConsoleForegroundColor::White);
		}

		// Compute path traveled from the source ray
		std::unordered_set<Ray> processedRays;
		std::stack<Ray> raysToProcess;
		raysToProcess.push(sourceRay);
		bool isSourceRay = true;
		while (!raysToProcess.empty())
		{
			// Process the next ray
			Ray currentRay = raysToProcess.top();
			raysToProcess.pop();

			// Skip the ray if we've already processed it
			if (processedRays.contains(currentRay))
			{
				continue;
			}
			processedRays.insert(currentRay);

			// Find the end of the ray
			Vector2d<int> end = rays.at(currentRay);

			// Source ray starts out of bounds; nudge it back in bounds
			if (isSourceRay)
			{
				currentRay.start += currentRay.direction;
				isSourceRay = false;
			}

			// Mark tiles touched by the ray as energized
			for (int y = std::min(currentRay.start.y, end.y); y <= std::max(currentRay.start.y, end.y); ++y)
			{
				for (int x = std::min(currentRay.start.x, end.x); x <= std::max(currentRay.start.x, end.x); ++x)
				{
					energizedTiles.at(x, y) = '#';

					if (shouldRender)
					{
						renderer.Draw(x, y, grid.at(x, y), ConsoleForegroundColor::IntenseWhite, ConsoleBackgroundColor::IntenseYellow);
					}
				}
			}

			if (shouldRender)
			{
				renderer.Present();

				renderer.DrawGrid(0, 0, grid, ConsoleForegroundColor::White);
				for (int y = 0; y < grid.Height(); ++y)
				{
					for (int x = 0; x < grid.Width(); ++x)
					{
						renderer.Draw(x, y, grid.at(x, y), ConsoleForegroundColor::White, energizedTiles.at(x, y) == '#' ? ConsoleBackgroundColor::Yellow : ConsoleBackgroundColor::Black);
					}
				}
			}

			// Compute the next ray(s) to process
			switch (grid.at(end))
			{
				case '/':
					if (currentRay.direction == up)
					{
						raysToProcess.push({ right, end });
					}
					else if (currentRay.direction == down)
					{
						raysToProcess.push({ left, end });
					}
					else if (currentRay.direction == left)
					{
						raysToProcess.push({ down, end });
					}
					else if (currentRay.direction == right)
					{
						raysToProcess.push({ up, end });
					}
					break;
				case '\\':
					if (currentRay.direction == up)
					{
						raysToProcess.push({ left, end });
					}
					else if (currentRay.direction == down)
					{
						raysToProcess.push({ right, end });
					}
					else if (currentRay.direction == left)
					{
						raysToProcess.push({ up, end });
					}
					else if (currentRay.direction == right)
					{
						raysToProcess.push({ down, end });
					}
					break;
				case '|':
					if (currentRay.direction == left || currentRay.direction == right)
					{
						raysToProcess.push({ up, end });
						raysToProcess.push({ down, end });
					}
					break;
				case '-':
					if (currentRay.direction == up || currentRay.direction == down)
					{
						raysToProcess.push({ left, end });
						raysToProcess.push({ right, end });
					}
					break;
			}
		}

		if (shouldRender)
		{
			renderer.MoveCursorBelowRenderer();
		}

		std::cout << std::ranges::count(energizedTiles, '#');
	}
} // namespace Puzzle16A